use std::thread;

/// 闭包是将函数，或者说代码和其环境一起存储的一种数据结构，
/// 闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，
/// 成为闭包类型的一部分
///
/// 闭包会根据内部的使用情况，捕获环境中的自由变量，
/// 在Rust 中，闭包可以使用 |args| {code| 来表述
///
/// 除了用引用来捕获自由变量之外 ，还有另外一个方法使用 move 关键字
/// move |args| {code}
///
/// F: FnOnce() -> T 表明 F 是一个接受 0 个参数，返回 T 的闭包，FnOnce 稍后再说
/// F: Send + 'static 说明闭包 F 这个数据结构，需要静态生命周期或者拥有所有权，
/// 并且它还能被发送给另一个线程
///
/// T: Send + 'static 说明闭包F返回的数据结构T，需要静态生命曲或者拥有所有权，
/// 并且还能被 发送给另一个线程
///
/// 一个闭包，不就是一段代码 + 被捕获的变量么，
/// 需要静态生命周期或者拥有所有权是什么意思
///
/// 代码自然是静态生命周期了，是不是意味着被捕获的变量，
/// 需要静态生命周期或者拥有所有权
///
/// 的确如此，在使用 thread::spawn 时，我们需要使用 move 关键字，
/// 把变量的所有权从当前作用域移动到闭包的作用域，
/// 让thread::spawn 可以正常编译通过
///
/// 闭包是一种匿名类型，一旦声明，就会产生一个新的类型，
/// 但是这个类型无法被 其他地方使用，
/// 这个类型就像一个结构体，会包含所有捕获的变量
///
/// 所以闭包是一个特殊的结构体？
fn main() {
    let s = String::from("hello world");
    let handle = thread::spawn(move || {
        println!("{}", s);
    });

    handle.join().unwrap();


}