/// Vec<T> 是 3 个 word 的胖指针，
/// 包含
/// 一个指向堆内存的指针 pointer
/// 分配的堆内存的容量 capacity
/// 数据在堆内存的长度
///
/// 很多动态大小的数据结构，在创建时都是有类似的内存布局，
///     栈内存放的胖指针
///     指向堆内存分配出来的数据
///
/// 值的使用
///
/// 对 Rust 而言，一个值如果没有实现 copy，在赋值，传参数以及函数返回时会被 move
/// 其实 copy move 在内部实现上，都是浅层的按位做内存复制，
/// 只不过 copy 允许你访问之前的变量，而 move 不允许，
///
/// 在我们的认知中，内存复制是个很重的操作，确实是这样，如果你的关键路径中的每次调用，
/// 都要复制几百 k 的数据，比如一个大数组，是很低效的
///
/// 但是，如果你要复制的只是原生类型 copy 或者 栈上的胖指针，不涉及堆内存的复制，
/// 也就是深拷贝 deep copy，那这个效率是非常高的，我们不必担心每次赋值或者每次传参带来的性能损失
///
/// 所以，无论是 copy 还是 move ，它的效率都是非常高的
///
/// 不过也有一个例外，对于栈上的大数组传参，由于要复制整个数组，会影响效率，
/// 所以，一般我们不建议在栈上放大数组，如果实在需要，那么在传递这个数组时，
/// 最好用传引用而不是传值
///
/// 在使用值的过程中，除了 move，你要注意值的动态增长，因为在 Rust 中，集合类型的
/// 数据结构，都会在使用过程中自动扩展，
///
/// 以一个 Vec<T> 为例，当你使用完堆内存目前的容量后，还继续添加新的内容，就会触发堆内存的自动增长
/// 有时候，集合类型里的数据不断进进出出，导致集合一直增长，但是只使用了很小部分的容量，
/// 内存的使用率很低，所以要考虑使用 shrink_to_fit 方法，来节约对内存的使用
///
/// 值的销毁
///
/// 当所有者离开作用域，它拥有的值会被丢弃，
/// 从代码层面 ，Rust 到底是如何丢弃的呢，
///
/// 这里用到的 drop trait，类似于面向对象编程中的析构函数，当一个值要被释放时，
/// 它的 drop trait 会被调用，比如下面的代码， greeting 是一个字符串，在退出作用域时，
/// 其 drop() 函数会被自动调用，释放堆上包含 hello world 的内存，然后再释放栈上的内存
///
///
/// 如果要释放的值 是一个复杂的数据结构，比如一个结构体，那个这个结构体在调用 drop()时，
/// 会依次调用每一个域的 drop() 函数，如果域又是一个复杂的结构体或者集合类型，
/// 就会递归下去，直到每一个域都被释放干净
///
/// 代码中的 student 变量是一个结构体， name age scores，其中 name 是 String,
/// scores 是 hashMap ，它们本身需要额外 drop()，又因为 HashMap 的 key 是 String，
/// 所以还需要进一步调用这些 key 的 drop() ，整个释放顺序从内到外是：先释放 HashMap 下的key,
/// ，再释放 hashMap 堆上的表结构，最后释放栈上的内存
///
/// 堆内存释放，
///
/// 所有权机制决定了，一个值只能有一个所有者，所以在释放堆内存的时候，整个过程简单清晰，
/// 就是单纯调用 drop trait，不需要有其他顾虑，这对值安全，也没有额外负担的释放能力，
/// 是 Rust 独有
///
///
/// 每个个体的行为都遵循着非常简单死板的规范，最终 ，大量简单的个体构造出一个高效且不出错的系统
///
///
/// 在Rust里，你自定义的数据结构 ，绝大多数情况下，不需要实现自己的 drop trait，
/// 编译器的 缺省行为就足够了，但是，如果你想自己控制  drop 行为，你也可以为这些
/// 数据结构实现它
///
///
/// 释放其他资源，
///
/// drop trait 主要是为了释放对堆内存，它还可以释放其他任何资源，比如 socket 锁 文件
///
/// 比如我创建一个文件 file，往里面写入 hello world，当 file 离开作用域时，不但它的内存会被释放，
/// 它占用的资源，操作系统打开的文件描述符，也会被释放，也就是文件会被自动的关闭
///
/// 在其他语言中，java python golang 都需要显式的关闭文件，避免资源的泄露，
/// 这是因为，即便 GC 能够大帮助开发者释放不再引用的内存，它并不能释放除内存外的其他资源
///
/// 而 Rust， 因为清晰的所有权定义，使编译器知道，当一个值离开 作用域的时候，
/// 这个值不会被任何人引用，它占用的资源，包括内存资源，都可以立即释放，而不会导致其他问题，
///
///
/// 关闭 socket file lock ，就是一个 close，好像没什么大不了，
///
/// 在业务代码中，有很大一部分要用来处理错误，当错误处理搅和进来，close 调用可能要添加更多的上下文，
///
fn main() {

}