
/// 通过单一所有权模式，Rust 解决了堆内存过于灵活，
/// 不容易安全高效释放的地问题，
/// 既避免了手工释放内存带来的巨大心智负担和潜在错误，
/// 又避免了全局引入追踪GC或者ARC这样额外机制带来的效率问题
///
/// copy 语义和值的生命周期，在其他语言中都是隐式存在的，
/// 只不Rust 把它们定义的更清晰，更明确地界定了使用的范围而已
///
/// 内存管理是任何语言的核心
///
/// 数据在内存中如何创建，如何存放，如何销毁 搞明白，
/// 之后阅读代码，分析问题才会有一种游刃有余的感觉
///
///
/// 内存管理
///
/// 栈内存 分配和释放都很高效，在编译期就确定好了，因而它无法安全承载
/// 动态大小或者生命周期超出帧存活范围之外 的值
///
/// 所以，我们需要运行时可以自由操控的内存，也就是堆内存，来弥补栈的缺点
///
///
/// 堆内存足够灵活，然而堆上数据的生命周期该如何 管理，成为了各大语言的心头大患
///
/// C 采用了未定义的方式，由开发者手工控制，C++ 在 C 的基础上改进，引入智能指针，
/// 半手工半自动，Java 和 dot net 使用 GC 对堆内存全面接管，堆内存进入了受控时代，
/// 所谓受控代码，就是代码在一个运行时下工作，
/// 由运行时来保证堆内存的安全访问
///
/// 而 Rust 的创建者们，重新审视了堆内存的生命周期，发现大部分堆内存的需求在于
/// 动态大小，小部分需求是更长的生命周期，
/// 所以它默认将堆内存的生命周期 和 使用它的栈的内存的生命周期绑定在一起，
/// 并留了个小口子 leaked 机制，让堆内存在需要的时候，
/// 可以有超出栈帧存活的生命周期
///
///
///
/// 我们看看 在 值 的创建，使用和销毁过程中，Rust 是如何管理内存的
///
///
/// 数据结构在内存中在布局，哪些字段在堆上，哪些字段在栈上，以及它大致的大小
///
/// 值 的创建
///
///     当我们为数据结构创建一个值时，并将其赋给一个变量时，
fn main() {

}