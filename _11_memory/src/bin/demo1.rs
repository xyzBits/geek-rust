use std::mem::{align_of, size_of};

/// 通过单一所有权模式，Rust 解决了堆内存过于灵活，
/// 不容易安全高效释放的地问题，
/// 既避免了手工释放内存带来的巨大心智负担和潜在错误，
/// 又避免了全局引入追踪GC或者ARC这样额外机制带来的效率问题
///
/// copy 语义和值的生命周期，在其他语言中都是隐式存在的，
/// 只不Rust 把它们定义的更清晰，更明确地界定了使用的范围而已
///
/// 内存管理是任何语言的核心
///
/// 数据在内存中如何创建，如何存放，如何销毁 搞明白，
/// 之后阅读代码，分析问题才会有一种游刃有余的感觉
///
///
/// 内存管理
///
/// 栈内存 分配和释放都很高效，在编译期就确定好了，因而它无法安全承载
/// 动态大小或者生命周期超出帧存活范围之外 的值
///
/// 所以，我们需要运行时可以自由操控的内存，也就是堆内存，来弥补栈的缺点
///
///
/// 堆内存足够灵活，然而堆上数据的生命周期该如何 管理，成为了各大语言的心头大患
///
/// C 采用了未定义的方式，由开发者手工控制，C++ 在 C 的基础上改进，引入智能指针，
/// 半手工半自动，Java 和 dot net 使用 GC 对堆内存全面接管，堆内存进入了受控时代，
/// 所谓受控代码，就是代码在一个运行时下工作，
/// 由运行时来保证堆内存的安全访问
///
/// 而 Rust 的创建者们，重新审视了堆内存的生命周期，发现大部分堆内存的需求在于
/// 动态大小，小部分需求是更长的生命周期，
/// 所以它默认将堆内存的生命周期 和 使用它的栈的内存的生命周期绑定在一起，
/// 并留了个小口子 leaked 机制，让堆内存在需要的时候，
/// 可以有超出栈帧存活的生命周期
///
///
///
/// 我们看看 在 值 的创建，使用和销毁过程中，Rust 是如何管理内存的
///
///
/// 数据结构在内存中在布局，哪些字段在堆上，哪些字段在栈上，以及它大致的大小
///
/// 值 的创建
///
///     当我们为数据结构创建一个值时，并将其赋给一个变量时，根据值 的性质，它有可能被创建在栈上，
/// 也有可能 被创建在堆上
///
/// 编译时可以确定大小的值都会被放在栈上，包括 Rust 提供的原生类型，字符，数组，元组等，
/// 以及开发者自定义的固定大小的结构体 struct 枚举 enum
///
/// 如果数据结构的大小无法确定，或者它们的大小确定但是在使用时需要更长的生命周期，
/// 就最好放在堆上
///
///
/// 来看 struct enum vec<T> string 这几种重要的数据结构在创建时的内存布局
///
/// struct
/// Rust 在内存中排布数据时，会根据每个域的对齐对数据进行重排，使其内存大小和访问效率最好好，
/// 比如，一个包含 A B C 三个域的 struct ，它在内存中的布局可能是 A C B
/// | A | B | C |   ---> | A | C | B |
/// 为什么 Rust 编译器会这么做呢，
///
/// 先看看 C 语言在内存中表达一个结构体时遇到的问题，来写一段代码，其中两个数据
/// 结构  S1 S2 都有三个域 a b c，其中 a c 都是 u8，占用一个字节，b 是 u16，
/// 占用两具字节，S1 在定义顺序是 a b c ，而 S2 在定义顺序是 a c b
///
/// 正确答案是 6 和 4
/// 为什么明明只用了 4 个字节，S1 的大小却是 6 呢，这是因为 CPU 在加载不对齐的内存时，
/// 性能会急剧下降，所以要避免用户定义不对齐的数据结构时，造成性能的影响
///
/// 对于这个问题，C 语言会对结构体做这样的处理
/// 1。 首先确定个域的长度和对齐长度，原始类型的对齐长度和类型的长度一致
/// 2。 每个域的起始位置和其对齐长度对齐，如果无法对齐，则添加 padding 直到对齐
/// 3。结构体的对齐大小和其最大域的对齐大小相同，而结构体的长度则四舍五入到其对齐的倍数
///
/// 对 S1 ，a 是 u8，
///
/// 如果结构体的定义考虑地不够周全，会为了对齐浪费很多空间，保存同样的数据，s1 s2 大小相差 50%
///
/// 使用 C 语言时，定义结构体的最佳实践是，充分考虑每一个域的对齐，合理地排列它们，
/// 使用其内存使用最高效，这个工作由开发者做会很费劲，尤其是嵌套的结构 体，需要仔细
/// 地计算才能得到最优解
///
///
///
/// 而 Rust 编译器替我们自动完成了这个优化，这就是为什么 Rust 会自动重排你定义的结构体
/// 来达到最高效率，
///
/// 显然，Rust 编译器默认为开发者优化结构体的排列，但你也可以用 #[repr] 宏，
/// 强制让 Rust 编译器不做优化，和 C 的行为一致，这样 Rust 代码可以方便地和 C
/// 代码无缝交互
///
///
///

#[repr()]
struct S1 {
    a: u8,
    b: u16,
    c: u8,
}

struct S2 {
    a: u8,
    c: u8,
    b: u16,
}
fn main() {
    println!("sizeof S1: {}, S2: {}", size_of::<S1>(), size_of::<S2>());
    println!("align_of S1: {}, S2: {}", align_of::<S1>(), align_of::<S2>());
}