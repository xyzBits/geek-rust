
/// 生命周期问题
/// 函数返回引用时，除非是静态引用，那么这个引用一定和带有引用的某个输入参数有关，
/// 输入参数可能是 &self, &mut self, &T &mut T
/// 我们要建立正确的输入和返回值之间的关系，这个关系和函数内部的实现无关，
/// 只和函数签名有关
///
/// &self &mut self 出现 时，返回值 的生命周期和它关联，
/// 因为大部分方法，如果返回引用，它基本上是引用 &self 里的某个参数
///
/// 当你要在函数执行过程中，创建的或者得到的数据，和参数无关，
/// 那么无论它是一个有所有权的数据，还是一个引用，你只能返回带有所有权的数据，
/// 对于引用，意味着调用 clone() 或者 to_owned() 来，从引用中得到所有权
///
///
/// 任何数据结构 T，都可以有指向它的引用 &T，所以 String &String 的区别，
/// 以及 String &str 的区别，压根是两个问题
///
/// 更好的问题是：为什么有了 String，还需要 &str，
/// 或者 String Vec<T> 这样连续存放的数据，还要有切片的概念
///
///
/// &str 是 String 的切片，也可以是 &str 的切片，
/// 它和 &[T] 一样，没有什么特别的，就是一个带着长度的胖指针，
/// 指向了一片连续的内存区域
///
/// 你可以这么理解 ，
/// 切片之于 Vec<T> String 等数据，
/// 就好比数据库里的视图 之于 table
///
///
///



fn main() {
    let hello = String::from("hello world");

    let hello_ref = &hello;

    let slice = &hello[..6];
    let sub_slice = &slice[1..4];
}