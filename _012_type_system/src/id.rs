
fn id<T>(x: T) -> T {
    x
}

/// 对于泛型函数，rust 会进行单态化处理，也就是在编译时，把所有乃至的泛型函数的泛型参数展开，
/// 生成若干个函数，所以，id()函数编译后会得到 一个处理后的多版本
fn id_int(x: i32) -> i32 {
    x
}

fn id_str(x: &str) -> &str {
    x
}
/// 单态化的好处是，泛型函数的调用是静态分pai，在编译时就一一对应，既保有多态的灵活性，又没有任何效率的损失，和普通函数的调用一样高效
///
/// 坏处就是，一个泛型函数，编译器需要找到所有用到的不同类型，一个个编译，编译慢和泛型单态化脱不开干系
/// 同时，这样编译出来的二进制会比较大，因为泛型函数的二进制 代码实际存在N份
///
/// 因为单态化，代码以二进制分发会损失泛型信息，如果我写了一个库，提供了如上的id函数，使用这个库的开发者如果拿到的是二进制，
/// 那么这个二进制中必须带有原始的泛型函数，才能正确调用 ，但单态化后，原本的泛型信息就被丢弃了

fn main() {
    let int = id::<i32>(19);
    let string = id("Tyr");
    println!("int = {}, string = {}", int, string);
}