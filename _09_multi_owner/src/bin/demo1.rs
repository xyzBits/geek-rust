use std::rc::Rc;

/// 单一所有权规则，能满足大部分场景中分配和使用内存的需求，而在编译时，rust
/// 通过借用检查 器就能完成静态检查，不会影响运行时效率
///
/// 一个有向无环图，某个节点可能有两个以上的节点指向它，按照所有权如何表达
/// 多个线程要访问一块共享内存，如何处理
///
/// 这些问题在程序运行过程中都会遇到，在编译期，所有权的静态检查无法处理它们，
/// 所以为了更好的灵活处理，Rust 提供了运行时的动态检查 ，来满足特殊场景下的需求
///
/// 这也是Rust处理很多问题的思路，编译时，处理大部分使用场景，保证安全性和效率，
/// 运行时，处理无法编译时无法处理的场景，会牺牲一部分效率，提高灵活性，
/// 后续讲到静态分发，动态分发也会有体现，
///
/// Rc Reference Counter
/// Arc Atomic reference counter
///
/// Rc，对于某个数据结构  T，我们可以创建引用计数 Rc，使其有多个所有者，
/// Rc 会把对应的数据结构创建在堆上，
/// 堆是唯一可以让动态创建的数据被到处使用的内存
///
/// 之后，如果相对数据创建更多的所有者，我们可以通过 clone() 来完成
///
/// 对于一个 Rc 进行 clone() 时，不会将其内部的数据复制，只会增加引用计数，
/// 而当一个 Rc 结构离开作用域被 drop()时，也只会减少其引用计数，直到引用计数为零，
/// 才会真正清除对应的内存
///
/// a b c 它们共同指向堆上相同的数据
/// 也就是说，堆上的数据有了三个共享的所有者
///
/// 为什么我们生成了对同一块内存的多个所有者，但是，编译器不抱怨所有权冲突
///
/// Rc 的 clone() 不复制实际的数据，只会增加一个引用计数器
///
/// Rc 是怎么产生在堆上，并且这段堆内存不受栈内存生命周期的控制
///
///
fn main() {
    let a = Rc::new(1);

    let b = a.clone();
    let c = a.clone();
}