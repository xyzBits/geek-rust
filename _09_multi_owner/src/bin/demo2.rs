use std::rc::Rc;

/// 在所有权模型下，堆内存的生命周期，和创建它的栈内存的生命周期保持一致
/// 所以Rc的实现似乎与此格格不入，
/// 的确，如果完全按照上一讲的单一所有权模型，Rust 是无法处理 Rc 这样的引用计数
///
/// Rust 必须 提供一种机制，让代码可以像 c c++ 一样，创建不受栈内存控制的堆内存，
/// 从而绕过编译时的所有权规则，
/// Rust 提供的方式是 Box::leak()
///
/// Box 是 Rust 下的智能指针，它可以强制把任何数据结构创建在堆上，然后在栈上放一个指针
/// 指向这个数据结构，但此时堆内存的生命周期仍然是受控的，跟栈的指针一致
///
/// Box::leak()，顾名思义，它创建的对象，从堆内存上泄漏出去，不受栈内存控制 ，
/// 是一个自由的，生命周期可以大到和整个进程的生命周期一致的对象
///
/// 所以我们相当于主动撕开一个口子，允许内存泄漏，
/// c c++下，其实你通过 malloc 分配的每一片堆内存，
/// 都类似于 Rust 下的 Box::leak()，
///
/// 有了 Box::leak() ，我们就可以跳出 Rust 编译器的静态检查，保证 Rc 指向堆内存，
/// 有最大的生命周期，然后我们再通过引用计数，在合适的时机，
/// 结束这段内存的生命周期
///
/// Rust 如何进行所有权的 静态检查  和 动态检查
/// 静态检查 ，靠编译器保证代码符合所有权规则
/// 动态检查 ，通过 Box::leak 让堆内存拥有不受限的生命周期，然后在运行过程中，
/// 通过对引用计数的检查，保证这样的堆内存最终会得到释放
///
///
///
fn main() {
    let rc = Rc::new(1);


}