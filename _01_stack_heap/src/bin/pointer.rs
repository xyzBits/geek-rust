fn main() {
    // "hello world" 作为一个字符串常量，编译时被存入可执行文件的 .RODATA 段，
    // 然后在程序加载时，获得一个固定的内存地址
    // 执行 "hello world".to_string() 时，在堆上，一块新的内存被分配出来 ，
    // 并把hello world 逐个字节拷贝过去
    // 把堆上的数据赋值给 hello 时，hello 作为在栈上分配的一个变量，它需要知道堆上内存
    // 的地址，另外由于堆上数据的大小不确定且可以增长，还需要知道它的长度及它现在有多大
    //
    let hello = "hello world".to_string();

    // 字符串的数据结构，在编译时大小不确定，运行时执行到具体的代码才知道大小，
    // 长度不一样，say_name() 函数只有在运行的时候，才知道参数的具体长度
    // 所以无法将字符串放在栈上，只能将其放在堆上，然后在栈上分配对应的指针，引用堆上的内存
    say_name("Lindsey".to_string());
    say_name("Rosie".to_string());

    // 考虑调用栈的大小，避免栈溢出，一旦当前程序的调用栈超出了系统允许的最大栈空间
    // 无法创建新的frame，来运行下一个要执行的函数，就会发生栈溢出
    // 这里程序就会被系统终止，产生崩溃信息
    // 过大的栈内存分配是导致栈溢出的原因之一，更广为人知的是递归函数没有妥善终止

}


/// 对于存入栈上的值，它的大小在编译期间就需要确定，栈上存储的变量生命周期在当前调用栈的作用域内，无法跨调用栈引用
/// 堆可以存入大小未知或者动态伸缩的数据类型
/// 堆上存储的变量，其生命周期从分配后开始，一直到释放时才结束 ，
/// 因此堆上的变量允许多个调用栈之间的引用，
/// 栈上存放的数据是静态的，固定大小，固定生命周期
/// 堆上存放的数据是动态的，不固定大小，不固定生命周期
///
fn say_name(name: String) {}