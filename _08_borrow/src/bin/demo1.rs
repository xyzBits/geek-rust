/// 在 Rust 中，借用和引用是一个概念，只不过在其他语言中引用的意义和Rust不同，所以
/// Rust 提出了新概念借用，便于区分
///
///
///
/// 单一所有权解决了其他语言中值被俐共享带来的问题，但也引发了一些不便
/// 当你不希望值的所有权被转移，又因为没有实现 copy trait 而无法使用 copy 语义，
/// 你可以借用数据
///
/// borrow 允许一个值的所有权，在不发生转移的情况下，被其上下文使用，
///
/// 在其他语言中，引用是一种别名，多个引用拥有对值的无差别访问权限，本质上是共享了所有权，
/// 而在Rust下，所有的引用都只是借用了临时使用权，它并不破坏值的单一所有权约束
///
/// 因此在默认情况下，Rust 的借用都是只读的，
///
/// 如果想避免copy 或者 move， 可以使用借用，或者说引用
///
/// Rust 的所有参数传递都是传值，不管是copy 还是 move
/// 所以在Rust中，你必须显示地把某个数据的引用，传递给另一个函数
///
/// Rust的引用实现了 copy trait，所以按照 copy 的语义，这个引用会被复制一份交给要调用的函数，
/// 对于这个函数来说，它并不拥有数据本身，数据只是临时借给它使用，所有权还在原来的拥有者那里，
///
/// 在Rust 中，引用是一等公民，和其他数据类型地位相等


fn main() {
    let data = vec![1, 2, 3, 4];

    let data1 = data;

    println!("sum of data1: {}", sum(data) )
}

fn sum(data: Vec<i32>) -> i32 {
    data.iter().fold(0, |acc, x| acc + x)
}