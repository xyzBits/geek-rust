
/// 在任何语言里，栈上的值都有自己的生命周期，它和帧的生命周期一样，
/// 而 Rust 中，进一步明确这个概念，并且为堆上的内在也引入了生命周期
///
/// 在其他语言中，堆内在的生命周期是不确定的，或者是未定义的，
/// 因此，要么开发者手工维护，要么语言在运行时做额外的检查
///
/// 而在 Rust 中，除非显式地做 Box::leak() Box::into_raw() ManualDrop
/// 等动作，一般来说，堆内在的生命周期，会默认和其栈内存的生命周期绑定在一起
///
/// 所以在这种默认情况下，在每个函数的作用域中，编译器就可以对比值和其引用的生命周期，
/// 来确保 引用的生命周期不超出值的生命周期
///
/// 如果一个值的生命周期贯穿整个进程的生命周期，称为静态生命周期
///
/// 当值拥有表态生命周期，其引用也具有静态生命周期，
/// 在表述这种引用的时候，可以用 'static 来表示，
/// 比如 &'static str 代表这是一个具有静态生命周期的字符串引用
///
/// 一般来说，全局变量 静态变量 字符串字面量 等，都拥有静态生命周期
/// 上文中提到的堆内在，如果使用了 Box::leak()后，也具有静态生命周期
///
/// 如果一个值是在某个作用域中定义的，也就是说它被创建在栈上或者堆上，那么其生命周期是动态的
///
/// 当这个值的作用域结束时，值的生命周期也随之结束，
/// 对于动态生命周期，我们约定要用 'a 'b 'hello 这样的小写字符或者字符串来表述
/// ' 后面具体是什么名字不重要，
/// 它代表某一段动态的生命周期，其中 &'a str &'b str 表示这两个字符串引用的生命周期可能不一致
///
/// 分配在堆和栈上的内在有其各自的作用域，它们的生命周期是动态的
/// 全局变量 静态变量 字符串字面量 代码等内容，在编译时，会被编译到可执行文件的 bss data rodaata text段
/// 然后在加载时，装入内存，因而，它们的生命周期和进程的生命周期一致，所以是静态的
///
/// 所以，函数指针的生命周期也是静态的，因为函数在text段中，只要进程活着，其内存一直存在
///
///
fn main() {

    let s1 = String::from("Lindsey");
    let s2 = String::from("Rosie");

    let result = max(&s1, &s2);

    println!("bigger one: {}", result);

    let result = get_max(&s1);
    println!("bigger one: {}", result);
}


/// 函数接受两个字符串引用，返回其中比较大的那个字符串的引用
/// 无法编译通过，missing lifetime specifier
/// 也就是说，编译器在编译 Max 函数时，无法判断 s1 s2 和返回值的生命周期
///
/// 站在开发者的角度，代码理解起来非常直观，在main 函数中，s1 s2 两个值的生命周期一致
/// 它们的引用传给Max 函数后，无论谁的被返回，生命周期都不会超过 s1 s2
/// 创建一个新的函数 get_max ，它接受一个字符串引用，
/// 然后 Cynthia 这个字符串字面量比较大小，之前我们提到，
/// 字符中字面量的生命周期是静态的，而 s1 是动态的，它们的生命周期不一致
///
/// 当出现多个参数，它们的生命周期可能不一致，返回值的生命周期就不好确定了，
/// 编译器编译某个函数时，并不知道这个函数将来还有谁调用，怎么调用，
/// 所以函数本身携带的信息，就是编译器在编译时使用的全部信息
///
///
/// 根据这一点，再看示例代码，在编译 Max 时，参数 s1 s2 的生命周期是什么关系，
/// 返回值和参数的生命周期又有什么关系，编译器是无法确定的
///
/// 此时，就需要我们在函数签名中提供生命周期的信息，
/// 也就是生命周期标注  lifetime specifier
/// 在生命周期标注时，使用的参数叫做生命周期参数 lifetime parameter
/// 通过生命周期标注，我们告诉编译器这些引用间生命周期的约束
///
/// 生命周期参数的描述方式和泛型参数一致，不过只使用小写字母，
/// 两个参数 s1 s2，以及返回值都用 'a 来约束，
///
/// 生命周期参数，描述的是参数和参数之间、参数和返回值之间的关系，并不改变原有的生命周期
///
/// 在我们添加了生命周期参数后，s1 s2 的生命周期只要大于等于 outlive  'a
/// 就符合参数的约束，而返回值的生命周期同理，也需要大于等于 'a
///
/// 当 main 函数调用 Max 函数时，s1 s2 有相同的生命周期 'a
/// 所以满足 s1: &'a str, s2: &'a str 的约束，
/// 当 get_max 函数调用 max 是，cynthia 是静态生命周期，
/// 它大于 s1 生命周期 'a
/// 所以它也可以满足 max 的约束需求
///
fn max<'a>(s1: &'a str, s2: &'a str) -> &'a str {
    if s1 > s2 {
        s1
    } else {
        s2
    }
}
///
fn get_max(s1: &str) -> &str {
    max(s1, "Cynthia")
}